# 貪婪演算法 greedy

## Introduction

- 是一種基於貪婪策略的演算法，通常用於最優化問題。如最小生成樹、最短路徑、背包問題等。Greedy並沒有一定的實作形式，而僅僅是種理念。
- 貪心演算法的基本思路是：在每個階段選擇當前情況下最好或最優的選擇，從而希望能夠得到全局最好或最優的解。貪心演算法通常分成兩種類型：
    - 基於價值的貪心演算法：每次選擇能夠帶來最大價值的選項。一般步驟如下：
        1. 確定問題的最優化目標。
        2. 設計選擇策略，即每個階段選擇當前情況下最好或最優的選擇。
        3. 根據選擇策略逐步構建出最優解。
    - 基於覆蓋的貪心演算法：每次選擇能夠最大程度地覆蓋目標區域的選項，用於解決[集合覆蓋問題（Set Cover Problem）](https://zh.wikipedia.org/zh-tw/%E9%9B%86%E5%90%88%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98)。
    
    ### 以下為案例
    
    下面我們來看一個集合覆蓋問題的例子：
    
    假設我們需要將以下 10 個州的人口全部包含在一些城市中，每個城市的人口上限是 5 萬，並且給定了每個城市所涵蓋的州：
    
    | 州 | 人口 | 涵蓋城市 |
    | --- | --- | --- |
    | A | 300 | 1, 4 |
    | B | 150 | 1, 3, 4 |
    | C | 500 | 2, 5 |
    | D | 50 | 2, 4 |
    | E | 100 | 3, 5 |
    | F | 70 | 2, 3 |
    | G | 80 | 1, 2, 5 |
    | H | 120 | 1, 5 |
    | I | 180 | 1, 2, 4 |
    | J | 40 | 3, 4 |
    
    我們可以將每個州視為一個元素，每個城市視為一個子集，問題就變成了：找出最少的子集，使得這些子集中包含了所有的元素。
    
    貪心演算法的基本思路是：每次選擇能夠最大程度地覆蓋未被覆蓋的元素的子集，直到所有元素都被覆蓋。
    
    下面是貪心演算法的實現過程：
    
    1. 初始化：將所有元素視為未被覆蓋，將所有子集視為可用。
    2. 按照每個子集所能夠覆蓋的未被覆蓋元素數量排序，選擇能夠覆蓋最多未被覆蓋元素的子集，將這個子集加入到最終解集合中。
    3. 根據這個子集所涵蓋的元素，將這些元素標記為已被覆蓋。
    4. 重複步驟 2 直到所有元素都被覆蓋，得到最終解集合。
    
    在這個例子中，按照覆蓋未被覆蓋元素的數量排序，我們可以得到以下子集的覆蓋情況：
    
    子集 未被覆蓋元素 覆蓋元素
    {A, B, G} {C, D, E, F, H, I, J} A, B, G
    {C} {A, B, D, E, F, G, H, I, J} C
    {E, J} {A, B, C, D, F, G, H, I} E, J
    {H} {A, B, C, D, E, F, G, I, J} H
    因此，我們可以選擇這四個子集作為最終解集合，可以覆蓋所有的州。
    
    需要注意的是，貪心演算法無法保證求得最優解，因此我們得到的解可能不是最少子集的解，但可以用來求得一個近似最優解。
    
- 貪心演算法具有局部最優性，即每次選擇都是當前情況下最好或最優的選擇。然而，由於貪心演算法只關注當前情況下的最優解，因此無法保證得到全局最優解。
- 貪心演算法的運作效率較高且相較於其他容易實作，常見的GREEDY演算法包含：
    - Dijkstra's Algrithm： 單一路徑之最短距離
    - Huffman's Algorithm： 霍夫曼編碼或壓縮算法

## 背包問題實作

假設我們有一個容量為 C 的背包，以及 n 個物品，每個物品都有一個重量 w 和一個價值 v。我們需要在不超過背包容量的情況下，選擇一些物品裝入背包，使得這些物品的總價值最大。

對於背包問題，貪心演算法的具體步驟如下：

1. 根據每個物品的單位價值（價值/重量）進行排序。
2. 依次選擇單位價值最高的物品放入背包，直到背包已滿或所有物品都已選擇。

在這個過程中，我們每次選擇當前情況下單位價值最高的物品放入背包，以期望獲得盡可能多的價值。由於背包容量是固定的，因此只能選擇一部分物品放入背包，而不能選擇所有物品。透過不斷選擇當前情況下最好或最優的物品，我們可以得到一個近似於最優解的解。

以下是Python實現：

```python
def knapsack(C, items):
    items = sorted(items, key=lambda x: x[1]/x[0], reverse=True)  # 根據單位價值排序
    res = 0
    for item in items:
        if C >= item[0]:  # 背包還有剩餘空間
            res += item[1]
            C -= item[0]
        else:  # 背包已滿
            res += item[1] * C / item[0]
            break
    return res
```

接下來我們來解釋上面這段程式碼的運作過程：

1. 我們先將所有物品按照單位價值由高到低排序，這裡用了Python內置的 sorted函數，key參數指定排序方式為物品的單位價值。
2. 接著我們初始化總價值 res 為 0，依次遍歷每個物品。對於每個物品，如果背包還有剩餘空間，就把這個物品放入背包中，同時更新總價值 res 和背包剩餘空間 C。
3. 如果背包已經滿了，則只能把部分這個物品放入背包中，放入比例為 C/item[0]，同樣更新總價值 res，並跳出循環。
4. 最後返回總價值 res。

這樣，我們就完成了一個基於價值的貪心演算法，用來解決背包問題。

### 貪心演算法解決背包問題的時間和空間複雜度分析：

時間複雜度：

- 排序的時間複雜度為 O(n log n)，其中 n 為物品數量。
- 遍歷物品的時間複雜度為 O(n)。
因此，總時間複雜度為 O(n log n)，其中主要時間開銷在於排序操作。

空間複雜度：

- 空間複雜度主要取決於排序所使用的額外空間，一般而言為 O(n)。
- 另外，還需要保存一些變量，例如背包剩餘容量等，佔用的空間很小可以忽略不計。
因此，總空間複雜度為 O(n)。